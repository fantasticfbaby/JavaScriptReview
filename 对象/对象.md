1. 早期对象创建方式
```
var person = new Object(); 
person.name = "Nicholas"; 
person.age = 29; 
person.job = "Software Engineer";

person.sayName = function(){ 
    alert(this.name); 
};
 ```
2. 新对象创建方式--对象字面量
```$xslt
var person = {
    name: "Nicholas",
    age: 29,
    job: "Software Engineer",
    sayName: function () {
        alert(this.name);
    }
};
```
3. 数据属性

每一个普通数据都有`value,writable,enumerable,configurable`四大属性

每一个访问器都有`get,set,enumerable,configurable`四大属性

value: 数据值,默认undefined

writable: 是否可以修改value值, 默认true

enumerable: 是否可以通过for-in循环返回属性,默认true

configurable: 是否可以通过delete删除属性, 能否修改属性特性, 能否修改属性类别(数据属性/访问器属性), 默认true

以上的默认值指的是通过普通方式创建的默认值, 如果`Object.defineProperties`方式, 默认值为全是false

get: 方法, 更加灵活地获取数据

set: 方法, 更加灵活地设置数据

```
var person = {}
Object.defineProperties(person, {
    name: {
        value: "teefing"
    },
    _birth: { // _口头约定该属性为私有
        value: 1997,
        writable: true, // 能否修改属性
        enumerable: true, // 能否通过for-in返回属性
        configurable: false // 能否删除属性,能否修改属性特性,能否修改属性种类
    },
    age: {
        get() {
            return (new Date()).getFullYear() - this._birth
        },
        set(newValue) {
            this._birth = (new Date()).getFullYear() - newValue
        }
    }
})
```

可以通过 `Object.getOwnPropertyDescriptor()` 或者 `Object.getOwnPropertyDescriptors()`方法读取属性的特性

4. 对象创建--工厂模式

就是将早期的创建对象的模式用function封装起来

```$xslt
function createPerson(name, age, job) {
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function () {
        alert(this.name);
    };
    return o;

}

var person1 = createPerson("Nicholas", 29, "Software Engineer");
```

5. 对象创建--构造函数模式
1) 
```$xslt
function Person(name) {
    this.name = name;
    this.sayname = function () {
        console.log(this.name)
    }
}
person = new Person("Lili");
person.sayname();
```

构造函数模式没有显式创建对象,而是直接将属性和方法赋给了this,
再利用`new`能改变this指向的原理, 从而将对应的属性和方法赋给指定对象
2)
```$xslt
Person("Alice"); //构造函数当普通函数使用默认会绑定到global
global.sayname() // 浏览器中全局对象是window
```
上例中没有使用`new`,this的指向就是全局对象

3)
```$xslt
var o = new Object()
Person.call(o, "David");
o.sayname()
```
这例中通过使用`call`强制修改this指向,也可以做到`new`的效果

4)
```$xslt
var args = ["EEE", 11, 'male']
function Person1(name, age, sex) {
    this.name=name;
    this.age = age;
    this.sex = sex;
    this.sayage = function () {
        console.log(this.sex)
    }
}
Person1.apply(o, args)
console.log(o) // 发现sayname方法依然存在, 可以用于JavaScript的继承
o.sayage()
```
继续,这里使用`apply`方法, 在使用过程中发现3)中的sayname方法在新绑定的o中仍然存在,
这类似于java中的继承, 通过这种方法可以实现js的继承

5)
可以上面的代码,将function提出赋给一个变量, 对象的变量指向该function就可以了

